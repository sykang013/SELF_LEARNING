

//JS 세계관에서는 변수의 타입이 모두 any.
let 이름: boolean | number //:<원하는 데이터값> 해주면 넣을 타입을 설정해줄 수 있다. |을 사용해 or 로 정할수도 있음.
이름 = false
//에러를 만들어내줄 수 있기 때문에 협업시 매우 유용하다. 
//타입스크립트의 특성: 우변에 뭐가 들어와도 타입으로 인정해준다.
let 예제: '나도 TS월드에선 타입이야' //이걸 리터럴 타입이라고 함.
예제 = '나도 TS월드에선 타입이야' //대신 반드시 그 값이 들어와 함.

//-------------------------------------------
//타입을 변수에 담아서 밖으로 빼낼수도 있다.
type 유저타입 = {아이디: string, 아바타: string} //유저타입은 이런 객체 형태만 가질 수 있다.
type 사람타입 = {이름: string} //윗줄의 원본을 건드리지 않고 & 로 병합할 수 있다. 

let 유저: 사람타입 & 유저타입 //&연산자로 머징을 할 수 있다.(TS 세계관에서는 이렇게 쓰임))
유저 = {아이디: '123', 이름:'김철수', 아바타: '123'}

//-------------------------------------------
//인터페이스 사용
interface 사람타입2 { //인터페이스에는 숨겨진 능력이 두개가 있다. 중요함. 상속이 됨. 
    이름: string
}

//인터페이스의 기능1 : 상속이 된다(클래스랑 비슷)(유저는 유저이기 이전에 사람이란 것이다.)
interface 유저타입2 extends 사람타입2 {
    아이디: string,
    아바타: string

}

//인터페이스의 기능2 : 머지가 된다
//이름이 같으면 하나로 합쳐버린다.
interface 유저타입3{
    이름:string
}

interface 유저타입3{
    아이디: string,
    아바타: string
}

let 유저합침: 유저타입3
유저합침 = {아이디: '123', 아바타:'123', 이름:"김영희"}


//-------------------------------------------

const 함수 = (숫자일걸: number | undefined) => {
    if (!숫자일걸) {
        throw new TypeError('숫자만 넣어야됨')
    } //if문으로 범위를 한번 좁힌것. 이걸 narrowing이라고 한다. 

    return 숫자일걸+1
}

함수(0)
함수(1)

